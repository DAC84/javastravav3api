{"name":"Javastravav3api","tagline":"Strava API v3 implementation written in Java v8","body":"javastravav3api\r\n===============\r\n\r\nStrava API v3 implementation written in Java v8\r\n\r\nJavastrava is a functionally complete implementation of the [Strava API (v3)](http://strava.github.io/api/). It includes all the changes made to the API up to October 8, 2015.\r\n\r\nIt consists of 2 layers which implement the API:\r\n\r\n1. A raw implementation of the API using [Retrofit](http://square.github.io/retrofit/) - with this it's up to your code to deal with exceptions, and Strava's foibles\r\n2. An abstracted implementation of the API which simplifies and abstracts the API, as well as adding several useful features (automatic handling of 404 and 401 errors; dealing with rate limiting; dealing with privacy; and handling a bunch of workarounds where the behaviour of the API is inconsistent) and removing some restrictions (particularly on paging)\r\n\r\nMaven\r\n=====\r\njavastrava is available on Maven. Just add this to your POM:\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>com.github.danshannon</groupId>\r\n\t<artifactId>javastrava-api</artifactId>\r\n\t<version>1.0.1</version>\r\n</dependency>\r\n```\r\n\r\nUse (full implementation)\r\n=========================\r\nTo use Javastrava, all you really need is an access token. Javastrava doesn't provide a mechanism for acquiring one via OAuth - it's a vanilla, headless implementation of the API. You will need to register with Strava for an API key, and you will get an API key (access token) automatically when you register your app. There is a hack which gets tokens through the OAuth process on the Strava website built into the test suite, see `test.utils.TestUtils.getValidToken()`, but remember that it's a hack!\r\n\r\nBasically, once you've gone through the OAuth validation process, Strava returns a one-off code. You then need to exchange that code for a token:\r\n\r\n```java\r\nAuthorisationService service = new AuthorisationServiceImpl();\r\nToken token = service.tokenExchange({application_client_id}, {client_secret}, code);\r\n```\r\n\r\nOnce you've got an access token, life is pretty simple really. Getting a service implementation looks like this:\r\n\r\n```java\r\nStrava strava = new Strava(token);\r\n```\r\n\r\nThen, getting an athlete looks like this:\r\n\r\n```java\r\nStravaAthlete athlete = strava.getAthlete(id);\r\n```\r\n\r\nUse (raw synchronous API)\r\n=============\r\nIf you prefer to use the raw API, then a similar approach is required. Again, it's your problem to get through the OAuth process until you've got a code. Then, to get a token:\r\n\r\n```java\r\nAuthorisationAPI auth = API.authorisationInstance();\r\nTokenResponse response = auth.tokenExchange({application_client_id}, {client_secret}, code);\r\nToken token = new Token(response);\r\n```\r\n\r\nNow we can get an API instance:\r\n\r\n```java\r\nAPI api = new API(token);\r\n```\r\n\r\nAnd finally, the athlete:\r\n\r\n```java\r\nStravaAthlete athlete = api.getAthlete(id);\r\n```\r\n\r\nUse (raw asynchronous API)\r\n==========================\r\nWe've also implemented an asynchronous version of the API. \r\n\r\nIts use is very similar to the synchronous API, but instead the asynchronous methods return a `CompletableFuture` that you can call later to retrieve the results, after doing something else\r\n\r\n```java\r\nAPI api = new API(token)\r\nCompletableFuture<StravaAthlete> future = api.getAthleteAsync(id);\r\n\r\n// Now you can do something else while you wait for the result\r\ndoSomethingInterestingInsteadOfWaiting();\r\n\r\n// And when you're ready, get the athlete from the future...\r\nStravaAthlete athlete = future.complete();\r\n```\r\n\r\nCaching\r\n=======\r\nThe full implementation provides a caching mechanism to reduce the overall number of calls to the Strava API. The caching mechanism uses [Apache JCS](https://commons.apache.org/proper/commons-jcs/) and your application will need to provide a cache.ccf configuration file to make use of it.\r\n\r\nThe raw API does not cache data.\r\n\r\nToken Management\r\n================\r\nThe `TokenManager` class provides a cache for all active tokens, for all users who have given permission to your application. Token exchange (above) will add each token to the token manager via `TokenManager.instance().storeToken(token)`.\r\n\r\nYou can then retrieve a token from the TokenManager later on via `TokenManager.instance().retrieveToken(username)`. The username is the email address that the user logs in to Strava with; you can find it with `token.getAthlete().getEmail()`\r\n\r\nThe API doesn't currently cater for persistence of tokens or of the token manager; that's up to your application to do.\r\n\r\nTricks of the trade\r\n===================\r\nThe Strava API can be a bit, well, weird when you use it in anger. The interaction between privacy settings, authentication and so on isn't always consistent in the API. What we've done is this:\r\n\r\n- If the object you're after doesn't exist, service methods will return `null`. API methods will throw a `NotFoundException`\r\n- If the object you're after is private, service methods will return an empty object - either a list with no entries, or a model object with only the id populated. We don't worry about this too much from a privacy point of view, because all you get is that an object exists, but you don't get any of the data. Athletes are different - they are returned with a limited view of the athlete, rather than an empty athlete. API methods throw an `UnauthorisedException`\r\n- If your token has been revoked, or wasn't valid in the first place, you'll see an `InvalidTokenException` (which is unchecked) get thrown\r\n- If your token doesn't have the authorisation scope needed for the operation that you're attempting, you'll see an `UnauthorisedException` (which is unchecked) get thrown.\r\n- If you encounter network errors accessing the Strava API, a `StravaAPINetworkException` is thrown.\r\n- If you exceed your rate limit, then you'll see a `StravaAPIRateLimitException`.\r\n- If Strava returns a `503 Service Temporarily Unavailable` status, then you'll see a `StravaServiceUnavailableException`.\r\n- If Strava returns a `500 Internal Server Error`, then you'll get a `StravaInternalServerErrorException`.\r\n- Other unexpected errors will cause a `StravaUnknownAPIException` to be thrown.\r\n\r\nPaging\r\n======\r\nWe've provided a stack of alternate method signatures for all the API endpoints, both with and without the paging options. \r\n\r\nThe methods that do not include paging instructions will return only the first page from the Strava API, *not* everything. There are methods that *do* return everything, they're typically called `listAll*`. Be careful using these...\r\n\r\nThe methods that do include paging instructions are built to override the Strava paging limits. If you really want, you can ask for 10,000 or more activities at once, not Strava's artificial limit of 200 per page. Be aware, though, that internally we're still bound by the Strava limits, so asking for 10,000 activities will result in 50 calls to the API! That's going to exhaust your throttling limits (by default 600 calls every 15 minutes) pretty fast...\r\n\r\nObviously doing many sequential calls to the API to return all of something would be extremely slow, so the calls to the API are executed in parallel. See `javastrava.util.PagingHandler` for details of how this is done.\r\n\r\nTo use the paging options, you pass in a stravajava.util.Paging object as the pagingInstruction parameter. Have a look; it's amazimgly flexible!\r\n\r\nLeaderboards\r\n============\r\nThe Strava API is annoying when it passes your own results along with every page of a leaderboard. We've hacked that out, so that in the `stravajava.api.v3.model.StravaSegmentLeaderboard` definitions you'll see there are 2 collections of entries - <code>entries</code> is the one that you actually asked for, <code>athleteEntries</code> is the one that relates to the 5 entries around the authenticated athlete / you. Should be *much* simpler to deal with!\r\n\r\nTesting\r\n=======\r\nThere's a test suite at https://github.com/danshannon/javastrava-test\r\n\r\nDependencies\r\n============\r\n- The REST client is written using [Retrofit](http://square.github.io/retrofit/), because it makes life ridiculously easy\r\n- JSON serialisation uses [GSON](https://code.google.com/p/google-gson/)\r\n- Caching is implemented with [Apache JCS](https://commons.apache.org/proper/commons-jcs/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}